<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>量化价值投资前沿 - 资源导航</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Inter:wght@400;600&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f9fa;
            color: #212529;
            overflow: hidden; /* 隐藏滚动条 */
        }

        h1, h2, h3 {
            font-family: 'Noto Serif SC', serif;
        }

        /* 定义学术风格的颜色变量 */
        :root {
            --color-primary: #5D69B1; /* 靛蓝 */
            --color-secondary: #52BCA3; /* 青绿 */
            --color-accent: #E58601; /* 橙色 */
            --color-text: #343a40;
            --color-bg: #f8f9fa;
            --color-node-bg: rgba(93, 105, 177, 0.1);
            --color-node-border: rgba(93, 105, 177, 0.8);
            --color-node-text: #212529;
            --color-node-hover-bg: rgba(229, 134, 1, 0.2);
            --color-node-hover-border: rgba(229, 134, 1, 1);
        }

        #galaxy-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .content-overlay {
            position: relative;
            z-index: 1;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body class="bg-gray-50">

<canvas id="galaxy-canvas"></canvas>

<div class="content-overlay">
    <div class="container mx-auto px-4 text-center">
        <header class="mb-12">
            <h1 class="text-4xl md:text-5xl font-bold" style="color: var(--color-primary);">量化价值投资前沿</h1>
            <p class="mt-4 text-lg text-gray-600">学术资源与研究工具导航</p>
        </header>

        <main id="link-container" class="text-left max-w-4xl mx-auto">
            <p class="text-center text-gray-500 italic mb-8">
                提示：这是一个动态的资源网络。您可以点击画布中的节点，或下方的分类链接来访问相关网站。
            </p>
            <!-- 分类按钮将由JS动态生成 -->
            <div id="category-buttons" class="flex flex-wrap justify-center gap-3 my-8"></div>
        </main>

        <footer class="absolute bottom-4 left-0 right-0 text-center text-sm text-gray-400">
            <p>&copy; 2025 PB-ROE策略研究. 保留所有权利.</p>
        </footer>
    </div>
</div>

<script>
    // --- 数据定义 ---
    const links = [
        // 学术期刊
        { name: "Journal of Finance", url: "https://afajof.org/", category: "学术期刊" },
        { name: "JFE", url: "https://www.sciencedirect.com/journal/journal-of-financial-economics", category: "学术期刊" },
        { name: "RFS", url: "https://academic.oup.com/rfs", category: "学术期刊" },
        { name: "金融研究", url: "http://www.jryj.org.cn/", category: "学术期刊" },

        // 数据提供商
        { name: "CSMAR", url: "https://www.gtarsc.com/", category: "数据提供商" },
        { name: "Wind", url: "https://www.wind.com.cn/", category: "数据提供商" },
        { name: "WRDS", url: "https://wrds-www.wharton.upenn.edu/", category: "数据提供商" },
        { name: "Quandl", url: "https://www.quandl.com/", category: "数据提供商" },

        // 金融资讯
        { name: "Wall Street Journal", url: "https://www.wsj.com/", category: "金融资讯" },
        { name: "Financial Times", url: "https://www.ft.com/", category: "金融资讯" },
        { name: "Bloomberg", url: "https://www.bloomberg.com/", category: "金融资讯" },
        { name: "财新网", url: "https://www.caixin.com/", category: "金融资讯" },

        // 量化研究
        { name: "SSRN", url: "https://www.ssrn.com/index.cfm/en/", category: "量化研究" },
        { name: "ArXiv q-fin", url: "https://arxiv.org/archive/q-fin", category: "量化研究" },
        { name: "Quantpedia", url: "https://quantpedia.com/", category: "量化研究" },
        { name: "GitHub", url: "https://github.com/topics/quantitative-finance", category: "量化研究" },

        // 经典著作与人物
        { name: "Aswath Damodaran", url: "https://pages.stern.nyu.edu/~adamodar/", category: "经典著作" },
        { name: "Kenneth R. French", url: "https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/", category: "经典著作" },
        { name: "Robert J. Shiller", url: "http://www.econ.yale.edu/~shiller/", category: "经典著作" },
    ];

    // --- 动态画布实现 ---
    const canvas = document.getElementById('galaxy-canvas');
    const ctx = canvas.getContext('2d');
    let nodes = [];
    let mouse = { x: null, y: null };

    const colors = {
        primary: getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim(),
        nodeBg: getComputedStyle(document.documentElement).getPropertyValue('--color-node-bg').trim(),
        nodeBorder: getComputedStyle(document.documentElement).getPropertyValue('--color-node-border').trim(),
        nodeText: getComputedStyle(document.documentElement).getPropertyValue('--color-node-text').trim(),
        nodeHoverBg: getComputedStyle(document.documentElement).getPropertyValue('--color-node-hover-bg').trim(),
        nodeHoverBorder: getComputedStyle(document.documentElement).getPropertyValue('--color-node-hover-border').trim(),
    };

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    class Node {
        constructor(data) {
            this.data = data;
            this.radius = data.name.length * 3.5 + 25;
            this.x = canvas.width / 2 + (Math.random() - 0.5) * 200;
            this.y = canvas.height / 2 + (Math.random() - 0.5) * 200;
            this.vx = (Math.random() - 0.5) * 0.5;
            this.vy = (Math.random() - 0.5) * 0.5;
            this.isHovered = false;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.isHovered ? colors.nodeHoverBg : colors.nodeBg;
            ctx.fill();
            ctx.strokeStyle = this.isHovered ? colors.nodeHoverBorder : colors.nodeBorder;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            ctx.fillStyle = colors.nodeText;
            ctx.font = '13px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.data.name, this.x, this.y);
        }

        update() {
            // 边界碰撞检测
            if (this.x + this.radius > canvas.width || this.x - this.radius < 0) this.vx = -this.vx;
            if (this.y + this.radius > canvas.height || this.y - this.radius < 0) this.vy = -this.vy;

            // **调整**: 向心力/引力 (减弱)
            const gravityFactor = 0.0001; // <--- 显著降低了引力
            const dx_center = canvas.width / 2 - this.x;
            const dy_center = canvas.height / 2 - this.y;
            this.vx += dx_center * gravityFactor;
            this.vy += dy_center * gravityFactor;

            // 移动
            this.x += this.vx;
            this.y += this.vy;

            // 鼠标悬停检测
            const dist = Math.hypot(this.x - mouse.x, this.y - mouse.y);
            this.isHovered = dist < this.radius;

            // 减速
            this.vx *= 0.97; // <--- 稍微增加阻尼，让动态更平滑
            this.vy *= 0.97;
        }
    }

    function init() {
        resizeCanvas();
        nodes = links.map(link => new Node(link));
        animate();
        setupUI();
    }

    function handleInteractions() {
        // **调整**: 节点间排斥力 (增强)
        const repulsionFactor = 0.2; // <--- 增加了排斥力
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const nodeA = nodes[i];
                const nodeB = nodes[j];
                const dx = nodeB.x - nodeA.x;
                const dy = nodeB.y - nodeA.y;
                const dist = Math.hypot(dx, dy);
                const minDist = nodeA.radius + nodeB.radius + 10; // 增加最小间距

                if (dist < minDist) {
                    const angle = Math.atan2(dy, dx);
                    const force = (minDist - dist) * repulsionFactor;
                    const fx = Math.cos(angle) * force;
                    const fy = Math.sin(angle) * force;

                    // 应用力时，考虑质量（半径）的反比，让大节点惯性更大
                    const massA = nodeA.radius;
                    const massB = nodeB.radius;

                    nodeA.vx -= fx / massA;
                    nodeA.vy -= fy / massA;
                    nodeB.vx += fx / massB;
                    nodeB.vy += fy / massB;
                }
            }
        }
    }

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        handleInteractions();

        // 绘制节点间的连接线
        ctx.strokeStyle = 'rgba(93, 105, 177, 0.15)';
        ctx.lineWidth = 1;
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const dist = Math.hypot(nodes[i].x - nodes[j].x, nodes[i].y - nodes[j].y);
                if (dist < 300) {
                    ctx.beginPath();
                    ctx.moveTo(nodes[i].x, nodes[i].y);
                    ctx.lineTo(nodes[j].x, nodes[j].y);
                    ctx.stroke();
                }
            }
        }

        nodes.forEach(node => {
            node.update();
            node.draw();
        });

        requestAnimationFrame(animate);
    }

    // --- UI交互 ---
    function setupUI() {
        const categories = [...new Set(links.map(l => l.category))];
        const buttonsContainer = document.getElementById('category-buttons');
        buttonsContainer.innerHTML = ''; // 清空旧按钮

        categories.forEach(category => {
            const button = document.createElement('button');
            button.textContent = category;
            button.className = 'px-4 py-2 rounded-full text-sm font-semibold transition-all duration-300';
            button.style.backgroundColor = colors.nodeBg;
            button.style.color = colors.primary;
            button.style.border = `1px solid ${colors.nodeBorder}`;

            button.addEventListener('mouseover', () => {
                button.style.backgroundColor = colors.nodeHoverBg;
                button.style.borderColor = colors.nodeHoverBorder;
            });
            button.addEventListener('mouseout', () => {
                button.style.backgroundColor = colors.nodeBg;
                button.style.borderColor = colors.nodeBorder;
            });

            button.addEventListener('click', (e) => {
                e.preventDefault(); // 防止页面跳转
                const categoryNodes = nodes.filter(node => node.data.category === category);
                if (categoryNodes.length > 0) {
                    window.open(categoryNodes[0].data.url, '_blank');
                }
            });

            buttonsContainer.appendChild(button);
        });
    }


    // --- 事件监听 ---
    window.addEventListener('resize', () => {
        resizeCanvas();
        init(); // 窗口变化时重新初始化整个场景
    });

    canvas.addEventListener('mousemove', (event) => {
        mouse.x = event.clientX;
        mouse.y = event.clientY;

        const isOverNode = nodes.some(node => node.isHovered);
        canvas.style.cursor = isOverNode ? 'pointer' : 'default';
    });

    canvas.addEventListener('click', () => {
        const clickedNode = nodes.find(node => node.isHovered);
        if (clickedNode) {
            window.open(clickedNode.data.url, '_blank');
        }
    });

    // --- 启动 ---
    init();

</script>
</body>
</html>
